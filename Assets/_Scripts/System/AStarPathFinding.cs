using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// A* pathfinding helper for the grid generated by WorldDecomposer.
/// Converts world-space positions to grid cells, and runs A* on the grid.
/// Then returns a list of world-space points to follow
/// </summary>
public static class AStarPathFinding
{
    // Directions: right, left, up, down
    private static Vector2Int[] Directions =
    {
        new Vector2Int(1, 0),
        new Vector2Int(-1, 0),
        new Vector2Int(0,1),
        new Vector2Int(0,-1)
    };

    // Node for open list
    // Pos = grid coordinates
    // f-score is f = (g + h)
    private struct Node
    {
        public Vector2Int Pos;
        public float F;

        public Node(Vector2Int pos, float f)
        {
            Pos = pos;
            F = f;
        }
    }

    // Run A* on world grid and return list of waypoints
    public static List<Vector3> FindPath(WorldDecomposer world, Vector3 startWorldPos, Vector3 targetWorldPos)
    {
        //Get world grid
        int[,] grid = world.GetWorldData();
        int rows = world.Rows;
        int cols = world.Cols;

        Vector2Int start = WorldToGrid(world, startWorldPos);
        Vector2Int goal = WorldToGrid(world, targetWorldPos);

        // Blocked cell handling
        if (IsBlocked(grid, rows, cols, start) || IsBlocked(grid, rows, cols, goal))
        {
            Debug.Log("A* path start or goal is blocked.");
            return null;
        }

        // open - unexplored
        // closed - explored
        // gCost - cost
        // cameFrom - used for repathing backwards 
        var open = new List<Node>();
        var closed = new HashSet<Vector2Int>();
        var gCost = new Dictionary<Vector2Int, float>();
        var cameFrom = new Dictionary<Vector2Int, Vector2Int>();

        //initilize start node
        gCost[start] = 0f;
        open.Add(new Node(start, Heuristic(start, goal)));

        // Main A* loop
        while (open.Count > 0)
        {
            // Pick node from open list with lowest F score
            int bestIndex = 0;
            for (int i = 1; i < open.Count; i++)
            {
                if (open[i].F < open[bestIndex].F)
                {
                    bestIndex = i;
                }
            }

            Node current = open[bestIndex];
            open.RemoveAt(bestIndex);
            // If current position is goal, rebuilt and return path
            if (current.Pos == goal)
            {
                List<Vector2Int> pathCells = ReconstructPath(cameFrom, start, goal);
                return GridPathToWorldPath(world, pathCells, startWorldPos.y);
            }

            closed.Add(current.Pos);

            // Check all neighbors
            foreach (var neighbor in GetNeighbors(current.Pos, rows, cols))
            {
                if (closed.Contains(neighbor))
                {
                    continue;
                }

                if (IsBlocked(grid, rows, cols, neighbor))
                {
                    continue;
                }

                float tentativeG = gCost[current.Pos] + 1f;

                // If no gCost for neighbor or we found a cheaper path
                if (!gCost.TryGetValue(neighbor, out float existingG) || tentativeG < existingG)
                {
                    gCost[neighbor] = tentativeG;
                    float f = tentativeG + Heuristic(neighbor, goal);
                    open.Add(new Node(neighbor, f));
                    cameFrom[neighbor] = current.Pos;
                }
            }
        }
        // No path found (not clicking floor)
        return null;
    }

    // Return blocked grid points
    private static bool IsBlocked(int[,] grid, int rows, int cols, Vector2Int cell)
    {
        int row = cell.y;
        int col = cell.x;

        if (row < 0 || row >= rows || col < 0 || col >= cols)
        {
            return true;
        }

        return grid[row, col] == 1;
    }

    // Manhattan distance - h(n) = |x1 - x2| + |y1 - y2|
    private static float Heuristic(Vector2Int a, Vector2Int b)
    {
        return Mathf.Abs(a.x - b.x) + Mathf.Abs(a.y - b.y);
    }

    // Valid neighbor cells
    private static IEnumerable<Vector2Int> GetNeighbors(Vector2Int cell, int rows, int cols)
    {
        foreach (var dir in Directions)
        {
            int newCol = cell.x + dir.x;
            int newRow = cell.y + dir.y;

            if (newCol >= 0 && newCol < cols && newRow >= 0 && newRow < rows)
            {
                yield return new Vector2Int(newCol, newRow);
            }
        }
    }


    // Path rebuilding - Rebuild path backwards from goal to start, then reverse
    private static List<Vector2Int> ReconstructPath(Dictionary<Vector2Int, Vector2Int> cameFrom, Vector2Int start, Vector2Int goal)
    {
        var path = new List<Vector2Int>();
        Vector2Int current = goal;

        path.Add(current);
        while (current != start)
        {
            current = cameFrom[current];
            path.Add(current);
        }
        path.Reverse();
        return path;
    }

    // Convert world positions to a grid cell index
    private static Vector2Int WorldToGrid(WorldDecomposer world, Vector3 pos)
    {
        int rows = world.Rows;
        int cols = world.Cols;
        int nodeSize = world.NodeSize;

        float startX = -(cols * nodeSize) / 2f;
        float startZ = -(rows * nodeSize) / 2f;

        int col = Mathf.FloorToInt((pos.x - startX) / nodeSize);
        int row = Mathf.FloorToInt((pos.z - startZ) / nodeSize);

        col = Mathf.Clamp(col, 0, cols - 1);
        row = Mathf.Clamp(row, 0, rows - 1);

        return new Vector2Int(col, row);
    }

    // Convert a list of grid cells into world-space positions
    private static List<Vector3> GridPathToWorldPath(WorldDecomposer world, List<Vector2Int> path, float yHeight)
    {
        int rows = world.Rows;
        int cols = world.Cols;
        int nodeSize = world.NodeSize;

        float startX = -(cols * nodeSize) / 2f;
        float startZ = -(rows * nodeSize) / 2f;
        float centerOffset = nodeSize / 2f;

        var result = new List<Vector3>(path.Count);

        foreach (var cell in path)
        {
            int col = cell.x;
            int row = cell.y;

            float x = startX + centerOffset + nodeSize * col;
            float z = startZ + centerOffset + nodeSize * row;

            result.Add(new Vector3(x, yHeight, z));
        }

        return result;
    }

}
